#ifndef _%TABLE%Table_ii_
#define _%TABLE%Table_ii_
/**
   File:        %TABLE%Table.hh
   Project:	%PRJ%
   Desc:        
  
    Inline source for %TABLE%Table
  
   Notes:
  
    Generated by %PERL_PKG% from %TMPL_SRC%
  
   Author:      %AUTHOR%
   Created:     %CREATED%
  
  Revision Info: (See cvs log for revision history)
  
    $Author$
    $Date$
    $Name$
    $Revision$
    $State$

  $Id$
**/


#if defined( %PRJ_UPCASE%_DEBUG )
#define inline
#endif

inline
bool
%TABLE%Table::LessRec::operator () ( const Rec & a, const Rec & b ) const
{
  // NEW_TABLE - not all field needed
  %KEY_COMPARE%

  return( false );
}

inline
%TABLE%Table::pair_iterator_bool
%TABLE%Table::insert( const Rec & rec, EffDate effDate )
{
  return( table.insert( rec ) );
}

inline
bool
%TABLE%Table::add( const Rec & rec, EffDate effDate )
{
  return( insert( rec ).second );
}

inline
%TABLE%Table::const_iterator
%TABLE%Table::find( const Rec & key, EffDate effDate ) const
{
  return( table.find( key ) );
}

// NEW_TABLE - not all field needed
inline
%TABLE%Table::const_iterator
%TABLE%Table::find(
  %FIND_KEY_FIELDS_ARGS%
  ) const
{
  Rec k;
  
  %FIND_KEY_FIELDS_METH%

  return( find( k ) );
}

// NEW_TABLE - not all field needed
%FIND_ASCII_IMPL%

inline
%TABLE%Table::iterator
%TABLE%Table::find( const Rec & key, EffDate effDate )
{
  return( table.find( key ) );
}

inline
%TABLE%Table::const_iterator
%TABLE%Table::end( void ) const
{
  return( table.end() );
}
    
inline
%TABLE%Table::const_iterator
%TABLE%Table::begin( void ) const
{
  return( table.begin() );
}
    
inline
%TABLE%Table::iterator
%TABLE%Table::end( void )
{
  return( table.end() );
}
    
inline
const %TABLE%Table::Rec *
%TABLE%Table::getRec( MultiMemOffset::Loc loc ) const
{
  return( (const Rec *)(dataMgr.address( loc ) ) );
}

inline
MultiMemOffset::Loc
%TABLE%Table::getRecLoc( const const_iterator & it ) const
{
  return( it == end() ? 0 : dataMgr.location( &(*it)) );
}

inline
int
compareData(
  const %TABLE%Table::Rec & a,
  const %TABLE%Table::Rec & b
  )
{
  int diff;
  
  // NEW_TABLE - not all field needed
%COMPARE_DATA%

   return( diff );
}

inline
DumpInfo< %TABLE%Table >
%TABLE%Table::dump( const char * prefix, bool showVer ) const
{
  return( DumpInfo< %TABLE%Table >( *this, prefix, showVer ) );
}


#if defined( inline )
#undef inline
#endif

// Local Variables:
// mode:c++
// End:

#endif // ! def _%TABLE%Table_ii_ 
